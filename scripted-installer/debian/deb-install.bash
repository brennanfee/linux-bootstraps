#!/usr/bin/env bash
# Author: Brennan Fee
# License: MIT License
# Version: 0.02  2021-11-05
#
# URL to install: bash <(curl -fsSL https://tinyurl.com/deb-install/deb-install.bash)
#
# For the development version: https://tinyurl.com/dev-deb-install/deb-install.bash
#
# This script installs Debian/Ubuntu the "Arch" way.  In order to have more
# fine-grained control it completely bypasses the Debian or Ubuntu installers
# and does all the setup here.  You must run the Debian (or Ubuntu) live
# "server" ISOs (which one shouldn't matter), truthfully it doesn't matter
# which one as you can install Ubuntu using the Debian ISO and Debian using
# the Ubuntu ISO.
#
# Bash strict mode
([[ -n ${ZSH_EVAL_CONTEXT:-} && ${ZSH_EVAL_CONTEXT:-} =~ :file$ ]] ||
 [[ -n ${BASH_VERSION:-} ]] && (return 0 2>/dev/null)) && SOURCED=true || SOURCED=false
if ! ${SOURCED}
then
  set -o errexit # same as set -e
  set -o nounset # same as set -u
  set -o errtrace # same as set -E
  set -o pipefail
  set -o posix
  #set -o xtrace # same as set -x, turn on for debugging

  shopt -s inherit_errexit
  shopt -s extdebug
  IFS=$(printf '\n\t')
fi
# END Bash scrict mode

### Start: Constants & Global Variables

# Should only be on during testing.  Primarly this turns on the output of passwords.
IS_DEBUG=${AUTO_IS_DEBUG:=0}

# Paths
WORKING_DIR=$(pwd)
LOG="${WORKING_DIR}/install.log"
OUTPUT_LOG="${WORKING_DIR}/install-output.log"
[[ -f ${LOG} ]] && rm -f "${LOG}"
[[ -f ${OUTPUT_LOG} ]] && rm -f "${OUTPUT_LOG}"
INSTALL_DATE=$(date -Is)
echo "Start log: ${INSTALL_DATE}" >> "${LOG}"
echo "------------" >> "${LOG}"
echo "Start log: ${INSTALL_DATE}" | tee -a "${OUTPUT_LOG}"
echo "------------" | tee -a "${OUTPUT_LOG}"

# Auto detected flags and variables
SYS_ARCH=$(uname -m) # Architecture (x86_64)
DPKG_ARCH=$(dpkg --print-architecture) # Something like amd64, arm64
UEFI=0

# Disk to types to accept as install locations for the auto selection methods
BLOCK_DISKS="3,8,9,22,33,34,65,66,67,202,253,259"

# This is not to be confused with the OS we are going to install, this is the OS that was booted to perform the install.  This script only supports Debian and Ubuntu Live Server installers images.
INSTALLER_DISTRO=$(lsb_release -i -s | tr "[:upper:]" "[:lower:]")

# The supported target OSes to be installed
SUPPORTED_OSES=('debian' 'ubuntu')

# Console font size, I pre-configure the console font to enlarge it which shoudl work better on higher resolution screens.
# The font family chosen is the Lat15-Terminus font family.  The only value changed here is the final size.
#
# Others small-ish: Lat15-Terminus14,Lat15-Terminus16,Lat15-Terminus18x10
# Others large-ish: Lat15-Terminus20x10,Lat15-Terminus22x11,Lat15-Terminus24x12,Lat15-Terminus28x14
CONSOLE_FONT_SIZE="20x10"

### End: Constants & Global Variables

### Start: Options & User Overrideable Parameters

# All options are read from environment variables and override the defaults.  It is expected that the user set whatever options they want before calling this script.  The overridable values all begin with "AUTO_" to indicate that they are for the "automatic" installation and to avoid potential collisions with other environment variables.
#
# Boolean values support "yes", "no", "true", "false", "0", "1", "y", "n", "t", and "f".

# The keymap to use.
AUTO_KEYMAP="${AUTO_KEYMAP:=us}"

# The OS to install, default is debian, alternative ubuntu.
AUTO_INSTALL_OS="${AUTO_INSTALL_OS:=debian}"

# The distro edition (sometimes called codename) to install.  For debian this is things like 'stable', 'bullesye', etc.  And for Ubuntu it is always the codename 'jammy', 'kinetic', etc.  For anything else that is "debian" like this is what should be placed into the APT sources.list.  If you do not provide a value, the default will be defined by each supported OS.  For instance, with Debian this will always be stable and for Ubuntu always the latest LTS edition.
AUTO_INSTALL_EDITION="${AUTO_INSTALL_EDITION:=stable}"

# For all distro's "default" will install the default kernel for the edition requested.  However, some distributions support alternate kernels.  For those, other values may be supported.  For instance, for Debian stable you can pass "backport" to install the kernel from the backports repository (if available).  For Ubuntu LTS editions you can choose "hwe" and "hwe-edge" as alternatives.
AUTO_KERNEL_VERSION="${AUTO_KERNEL_VERSION:=default}"

# The default hostname of the machine being created.  If none is passed the hostname will be autogenerated.
AUTO_HOSTNAME="${AUTO_HOSTNAME:=}"

# The domain for the machine being created.
AUTO_DOMAIN="${AUTO_DOMAIN:=}"

# The time zone for the machine being created.
AUTO_TIMEZONE="${AUTO_TIMEZONE:=America/Chicago}"  # Suck it east and west coast!  ;-)

# Whether to skip automatic partioning.  This is a boolean value.  Note, for this to work it is expected that prior to calling this script you have partitioned AND formatted the filesystems and mounted them at /mnt ready to be bootstrapped.  This can be done manually or with a given "early" script.  Furthermore, you still need to pass in the AUTO_MAIN_DISK value that indicates where you wish Grub to be installed (and you have prepared partitions for that).  With partitioning turned off you CAN NOT use "smallest" or "largest" for AUTO_MAIN_DISK and must pass in the device path (like /dev/sda).
AUTO_SKIP_PARTITIONING="${AUTO_SKIP_PARTITIONING:=0}"

# The main disk to install the OS and Grub to.  It can be a device (like /dev/sda) or a size match like "smallest" or "largest".  When automatic partitioning, for single disk envrionments we create a BIOS\UEFI partition, a /boot partition, and the rest of the disk a /root partition.
AUTO_MAIN_DISK="${AUTO_MAIN_DISK:=smallest}"

# What to do with a second disk on the machine.  This setting is ignored if only one disk is found on the machine.  But in cases where two or more disks are found this indicates what should happen.  A value of "ignore", the default, will ignore the second disk and install as though the machine had only one disk.  This is the default because it is the safest option.  Alternatively, you can pass a device (like /dev/sdb) which will select that as the second disk.  Lastly, as with the main disk, a size selector can be passed like "smallest" or "largest".  In the event that the main disk was selected by the same size selector, this would essentially be the next smallest or next largest disk.
#
# At no time can the second disk refer or resolve to the same disk as the main disk.  Such situations will result in an error and the script exiting.
#
# In dual disk automatic partitioning, no change is made to the main disk layout.  For the second disk, this script creates a single LVM volume on the second disk with one of two layouts (based on the AUTO_USE_DATA_FOLDER value).  Without the data option you get a single LVM partition of 70% for /home with 30% space free for later LVM expansion\use.  With the data folder option you get two partitions, 50% for /home, 30% for /data, and 20% empty and free for later LVM expansion\use.
AUTO_SECOND_DISK="${AUTO_SECOND_DISK:=ignore}"

# Whether to use a /data folder or partition on the target machine.  This folder is a convention that I follow and use and is therefore disabled by default.  I use it for all non-user specific files and setups (usually of docker files, configuraitons, etc.).  If being used along with the AUTO_SECOND_DISK option, this value does affect the partition scheme used.  For further details on this read the information under the AUTO_SECOND_DISK option.  This is a boolean value.
AUTO_USE_DATA_FOLDER="${AUTO_USE_DATA_FOLDER:=0}"

# After installation, the install log and some other files are copied to the target machine.  This indicates (overrides) the default location.  By default, the files are copied to the /srv folder unless AUTO_USE_DATA_FOLDER is enabled.  With AUTO_USE_DATA_FOLDER turned on the files are copied to the /data folder instead of /srv.  You can override these defaults by providing a path here.  Note that your path MUST start with a full path (must start with /).
AUTO_STAMP_FOLDER="${AUTO_STAMP_FOLDER:=}"

# Whether the volume(s) created should be encrypted.  This is a boolean value.
AUTO_ENCRYPT_DISKS="${AUTO_ENCRYPT_DISKS:=1}"

# The password to use for the main encrypte volume.  A special value of "file", the default, can be passed which will create a disk file in the /boot partition that will auto-decrypt on boot.  This is done so that any automated systems that expect a boot without the need of a password can still function.  You can also pass a full path (it must start with /) to a file to use, that file will be copied to the /boot partition to preserve the automatic boot nature required for automation.  Lastly, you can still provide an actual passphrase which again will be used for both disks in dual disk setup.  However, this method will break any automations as typing the password will be required at boot.
#
# In all configurations, if a second disk is being used a file will be generated automatically as the decryption key for the second disk and stored on the root partition (in the /etc/keys folder).  The system will be configured to automatically unlock that partition after the root partition is decrypted.
#
# NOTE: This is not intended to be a secure installation without the need for the user to modify things post bootstrap.  This merely "initializes" the encryption as it is much easier to modify the encryption keys\slots later than it is to encrypt a partition which is already in use (especially root).  Therefore, it is fully expected that the user will either replace the file or otherwise manage the encryption keys after initial boot.
AUTO_DISK_PWD="${AUTO_DISK_PWD:=file}"

# Whether root should be disabled.  This is a boolean value.  The default is to NOT disable the root account.  Some feel that disabling root is a more secure installation footprint, so this setting can be used for those that wish.
AUTO_ROOT_DISABLED="${AUTO_ROOT_DISABLED:=0}"

# If root is enabled, what the root password should be.  This can be a plain text password or a crypted password.  If you do not pass a root password, we will use the same password you passed for the AUTO_USER_PWD.  If that is also blank the password will be the target installed OS in all lower case ("debian" or "ubuntu", etc.)
AUTO_ROOT_PWD="${AUTO_ROOT_PWD:=}"

# Whether to create a user.  If the root user is disabled with the AUTO_ROOT_DISABLED option, this value will be ignored as in that case a user MUST be created and so we will force the creation of this user.  However, if root is enabled you can optionally turn off the creation of a normal user.
AUTO_CREATE_USER="${AUTO_CREATE_USER:=1}"

# The username to create, if not provied defaults to a username that matches the installed OS (debian or ubuntu).
AUTO_USERNAME="${AUTO_USERNAME:=}"

# The password for the created user.  If you do not provide a password it iwll default to the target installed OS in all lower case ("debian" or "ubuntu", etc.). The password can be a plain text password or a crypted password.
AUTO_USER_PWD="${AUTO_USER_PWD:=}"

# Whether the installer should pause, display the selected and calculated values and wait for confirmation before continuing.  Off by default to preserve fully automated installations.
AUTO_CONFIRM_SETTINGS="${AUTO_CONFIRM_SETTINGS:=0}"

# Whether to automatically reboot after the script has completed.   Default is not to reboot.  Automated environments such as Packer should turn this on.
AUTO_REBOOT="${AUTO_REBOOT:=0}"

### END: Options & User Overrideable Parameters

### START: Params created during verification

SELECTED_MAIN_DISK=""
SELECTED_SECOND_DISK=""
ENCRYPTION_FILE=""
SECONDARY_FILE=""

### END: Params created during verification

### START: Log Functions

write_log() {
  echo "LOG: ${1}" >> "${LOG}"
  if [[ ${IS_DEBUG} == "1" ]]
  then
    echo "LOG: ${1}" | tee -a "${OUTPUT_LOG}"
  fi
}

write_log_password() {
  if [[ ${IS_DEBUG} == "1" ]]
  then
    write_log "${1}"
  else
    local val
    val=${1//:*/: ******}
    write_log "${val}"
  fi
}

write_log_blank() {
  write_log ""
}

write_log_spacer() {
  write_log "------"
}

log_values() {
  write_log_spacer
  write_log "Post Validation Values"

  write_log_blank
  write_log "INSTALL_DATE: ${INSTALL_DATE}"
  write_log "INSTALLER_DISTRO: ${INSTALLER_DISTRO}"
  write_log "SYS_ARCH: ${SYS_ARCH}"
  write_log "DPKG_ARCH: ${DPKG_ARCH}"
  write_log "UEFI: ${UEFI}"
  write_log "IS_DEBUG: ${IS_DEBUG}"
  write_log_blank

  write_log "AUTO_KEYMAP: ${AUTO_KEYMAP}"
  write_log "AUTO_INSTALL_OS: ${AUTO_INSTALL_OS}"
  write_log "AUTO_INSTALL_EDITION: ${AUTO_INSTALL_EDITION}"
  write_log "AUTO_KERNEL_VERSION: ${AUTO_KERNEL_VERSION}"
  write_log "AUTO_HOSTNAME: ${AUTO_HOSTNAME}"
  write_log "AUTO_DOMAIN: ${AUTO_DOMAIN}"
  write_log "AUTO_TIMEZONE: ${AUTO_TIMEZONE}"
  write_log "AUTO_CONFIRM_SETTINGS: ${AUTO_CONFIRM_SETTINGS}"
  write_log "AUTO_REBOOT: ${AUTO_REBOOT}"
  write_log_blank

  write_log "AUTO_ROOT_DISABLED: ${AUTO_ROOT_DISABLED}"
  write_log_password "AUTO_ROOT_PWD: ${AUTO_ROOT_PWD}"
  write_log "AUTO_CREATE_USER: ${AUTO_CREATE_USER}"
  write_log "AUTO_USERNAME: ${AUTO_USERNAME}"
  write_log_password "AUTO_USER_PWD: ${AUTO_USER_PWD}"
  write_log_blank

  write_log "AUTO_SKIP_PARTITIONING: ${AUTO_SKIP_PARTITIONING}"
  write_log "AUTO_MAIN_DISK: ${AUTO_MAIN_DISK}"
  write_log "AUTO_SECOND_DISK: ${AUTO_SECOND_DISK}"
  write_log "AUTO_USE_DATA_FOLDER: ${AUTO_USE_DATA_FOLDER}"
  write_log "AUTO_STAMP_FOLDER: ${AUTO_STAMP_FOLDER}"
  write_log "AUTO_ENCRYPT_DISKS: ${AUTO_ENCRYPT_DISKS}"
  case "${AUTO_DISK_PWD}" in
    file)
      write_log "AUTO_DISK_PWD: file"
      ;;
    /*)
      write_log "AUTO_DISK_PWD: ${AUTO_DISK_PWD}"
      ;;
    *)
      write_log_password "AUTO_DISK_PWD: ${AUTO_DISK_PWD}"
      ;;
  esac
  write_log_blank
  write_log "MAIN_DISK_METHOD: '${MAIN_DISK_METHOD}'"
  write_log "SELECTED_MAIN_DISK: '${SELECTED_MAIN_DISK}'"
  write_log "SECOND_DISK_METHOD: '${SECOND_DISK_METHOD}'"
  write_log "SELECTED_SECOND_DISK: '${SELECTED_SECOND_DISK}'"
  write_log "ENCRYPTION_FILE: '${ENCRYPTION_FILE}'"
  write_log "SECONDARY_FILE: '${SECONDARY_FILE}'"

  write_log_blank
  write_log_spacer
}

confirm_with_user() {
  if [[ ${AUTO_CONFIRM_SETTINGS} == "1" || ${IS_DEBUG} == "1" ]]
  then
    print_title "Install Summary"
    print_title_info "Below is a summary of your selections and any detected system information.  If anything is wrong cancel out now with Ctrl-C.  Otherwise press any key to continue installation."
    print_line
    if [[ ${UEFI} == "1" ]]
    then
      print_status "The architecture is ${SYS_ARCH}, dpkg ${DPKG_ARCH}, and UEFI has been found."
    else
      print_status "The architecture is ${SYS_ARCH}, dpkg ${DPKG_ARCH}, and a BIOS has been found."
    fi

    blank_line

    print_status "The keymap to use is '${AUTO_KEYMAP}'."

    print_status "The distribution to install is '${AUTO_INSTALL_OS}', '${AUTO_INSTALL_EDITION}' edition."

    print_status "The kernel version to install, if available, is '${AUTO_KERNEL_VERSION}'."

    local domain_info
    if [[ ${AUTO_DOMAIN} != "" ]]
    then
      domain_info="The domain selected is '${AUTO_DOMAIN}'."
    else
      domain_info="No domain was provided."
    fi
    if [[ ${AUTO_HOSTNAME} == "" ]]
    then
      print_status "The hostname will be auto-generated. ${domain_info}"
    else
      print_status "The hostname selected is '${AUTO_HOSTNAME}'. ${domain_info}"
    fi

    print_status "The timezone to use is '${AUTO_TIMEZONE}'."

    blank_line
    if [[ ${AUTO_ROOT_DISABLED} == "1" ]]
    then
      print_status "The root account will be disabled."
    else
      print_status "The root account will be activated."
    fi

    if [[ ${AUTO_CREATE_USER} == "1" ]]
    then
      if [[ ${AUTO_USERNAME} == "" ]]
      then
        print_status "A default user '${AUTO_INSTALL_OS}' will be created and granted sudo permissions."
      else
        print_status "User '${AUTO_USERNAME}' will be created and granted sudo permissions."
      fi
    else
      print_status "User creation was disabled."
    fi

    blank_line
    print_status "The main disk option was '${AUTO_MAIN_DISK}', the selection method was '${MAIN_DISK_METHOD}', and the selected main disk is '${SELECTED_MAIN_DISK}'."

    print_status "The secondary disk option was '${AUTO_SECOND_DISK}', the selection method was '${SECOND_DISK_METHOD}', and the selected main disk is '${SELECTED_SECOND_DISK}'."

    if [[ ${AUTO_ENCRYPT_DISKS} == "1" ]]
    then
      print_status "The disks will be encrypted."
    else
      print_status "The disks will NOT be encrypted."
    fi

    blank_line
    pause_output
  else
    write_log "Skipping settings confirmation.  Option not selected."
  fi
}

### START: Log Functions

### START: Print Functions

# Text modifiers
RESET="$(tput sgr0)"
BOLD="$(tput bold)"

print_title() {
  clear
  print_line
  echo -e "# ${BOLD}$1${RESET}"
  write_log "SECTION: ${1}"
  print_line
  blank_line
}

print_title_info() {
  local T_COLS
  T_COLS=$(tput cols)
  T_COLS=$((T_COLS - 10))
  echo -e "${BOLD}$1${RESET}\n" | fold -sw "${T_COLS}" | sed 's/^/\t/'
  write_log "TITLE: ${1}"
}

print_line() {
  local T_COLS
  T_COLS=$(tput cols)
  printf "%${T_COLS}s\n" | tr ' ' '-'
  write_log_spacer
}

blank_line() {
  echo ""
  write_log_blank
}

print_status() {
  local T_COLS
  T_COLS=$(tput cols)
  T_COLS=$((T_COLS - 1))
  echo -e "$1${RESET}" | fold -sw "${T_COLS}"
  write_log "STATUS: ${1}"
}

print_info() {
  local T_COLS
  T_COLS=$(tput cols)
  T_COLS=$((T_COLS - 1))
  echo -e "${BOLD}$1${RESET}" | fold -sw "${T_COLS}"
  write_log "INFO: ${1}"
}

print_warning() {
  local YELLOW
  YELLOW="$(tput setaf 3)"
  local T_COLS
  T_COLS=$(tput cols)
  T_COLS=$((T_COLS - 1))
  echo -e "${YELLOW}$1${RESET}" | fold -sw "${T_COLS}"
  write_log "WARN: ${1}"
}

print_success() {
  local GREEN
  GREEN="$(tput setaf 2)"
  local T_COLS
  T_COLS=$(tput cols)
  T_COLS=$((T_COLS - 1))
  echo -e "${GREEN}$1${RESET}" | fold -sw "${T_COLS}"
  write_log "SUCCESS: ${1}"
}

pause_output() {
  print_line
  read -re -sn 1 -p "Press enter to continue..."
}

error_msg() {
  local RED
  RED="$(tput setaf 1)"
  local T_COLS
  T_COLS=$(tput cols)
  T_COLS=$((T_COLS - 1))
  echo -e "${RED}$1${RESET}\n" | fold -sw "${T_COLS}"
  write_log "ERROR: ${1}"
  exit 1
}

### START: Print Functions

### START: Helper Functions

setup_installer_environment() {
  # Locale
  sed -i '/en_US.UTF-8/ c\en_US.UTF-8 UTF-8' /etc/locale.gen
  locale-gen

  update-locale --reset LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8 LANGUAGE

  export LANG=en_US.UTF-8
  export LC_ALL=en_US.UTF-8
  export LANGUAGE=

  # Font
  setfont "Lat15-Terminus${CONSOLE_FONT_SIZE}"
}

get_exit_code() {
  EXIT_CODE=0
  # We first disable errexit in the current shell
  set +e
  (
    # Then we set it again inside a subshell
    set -e;
    # ...and run the function
    "$@"
  )
  EXIT_CODE=$?
  # And finally turn errexit back on in the current shell
  set -e
}

contains_element() {
  #check if an element exist in a string
  for e in "${@:2}"
  do
    [[ ${e} == "$1" ]] && break
  done
}

chroot_install() {
  write_log "Installing to target: '$*'"
  DEBIAN_FRONTEND=noninteractive arch-chroot /mnt apt-get -y -q --no-install-recommends install "$@"
}

package_exists() {
  arch-chroot /mnt apt-cache show "$1" &> /dev/null
  return $?
}

### END: Helper Functions

### START: System Verification Functions

check_root() {
  print_info "Checking root permissions..."

  local user_id
  user_id=$(id -u)
  if [[ "${user_id}" != "0" ]]
  then
    error_msg "ERROR! You must execute the script as the 'root' user."
  fi
}

check_linux_distro() {
  print_info "Checking installer distribution..."
  write_log "Installer distro detected: ${INSTALLER_DISTRO}"

  if [[ ${INSTALLER_DISTRO} != "debian" && ${INSTALLER_DISTRO} != "ubuntu" ]]
  then
    error_msg "ERROR! You must execute the script on a Debian or Ubuntu Server Live Image."
  fi
}

detect_if_eufi() {
  print_info "Detecting UEFI..."

  local vendor
  vendor=$(cat /sys/class/dmi/id/sys_vendor)
  if [[ "${vendor}" == 'Apple Inc.' ]] || [[ "${vendor}" == 'Apple Computer, Inc.' ]]
  then
    modprobe -r -q efivars || true # if MAC
  else
    modprobe -q efivarfs # all others
  fi

  if [[ -d "/sys/firmware/efi/" ]]
  then
    ## Mount efivarfs if it is not already mounted
    if [[ ! -d "/sys/firmware/efi/efivars" ]]
    then
      mount -t efivarfs efivarfs /sys/firmware/efi/efivars
    fi
    UEFI=1
  else
    UEFI=0
  fi
}

check_network_connection() {
  print_info "Checking network connectivity..."

  # Check localhost first (if network stack is up at all)
  if ping -q -w 3 -c 2 localhost &> /dev/null
  then
    # Test the gateway
    gateway_ip=$(ip r | grep default | awk 'NR==1 {print $3}')
    if ping -q -w 3 -c 2 "${gateway_ip}" &> /dev/null
    then
      # Should we also ping the install mirror?
      print_info "Connection found."
    else
      error_msg "Gateway connection not accessible.  Exiting."
    fi
  else
    error_msg "Localhost network connection not found.  Exiting."
  fi
}

### END: System Verification Functions

### START: Preparation Functions

install_prereqs() {
  print_info "Installing prerequisites"
  DEBIAN_FRONTEND=noninteractive apt-get -y -q update || true
  DEBIAN_FRONTEND=noninteractive apt-get -y -q full-upgrade || true

  install_debian_prereqs

  install_ubuntu_prereqs

  # Things they both need
  print_status "    Installing common prerequisites"
  DEBIAN_FRONTEND=noninteractive apt-get -y -q --no-install-recommends install vim debootstrap arch-install-scripts parted bc cryptsetup lvm2 xfsprogs laptop-detect

  DEBIAN_FRONTEND=noninteractive apt-get -y -q autoremove || true
}

install_debian_prereqs() {
  if [[ ${INSTALLER_DISTRO} == "debian" ]]
  then
    print_status "    Installing Debian prerequisites"

    DEBIAN_FRONTEND=noninteractive apt-get -y -q install console-data
  fi
}

install_ubuntu_prereqs() {
  if [[ ${INSTALLER_DISTRO} == "ubuntu" ]]
  then
    print_status "    Installing Ubuntu prerequisites"

    write_log "No Ubuntu specific prereqs at this time."
  fi
}

### END: Preparation Functions

### START: Parameter Verification Functions

normalize_variable_string() {
  local tmp
  tmp=$(echo "${!1}" | tr "[:upper:]" "[:lower:]")
  printf -v "$1" '%s' "${tmp}"
}

normalize_variable_boolean() {
  local input
  local output
  input=${!1}
  if [[ "${input}" == "yes" || "${input}" == "true" || "${input}" == "y" || "${input}" == "t" || "${input}" == "1" ]]
  then
    output="1"
  elif [[ "${input}" == "no" || "${input}" == "false" || "${input}" == "n" || "${input}" == "f" || "${input}" == "0" ]]
  then
    output="0"
  else
    echo "ERROR!!! Invalid option."
    exit 1
  fi

  printf -v "$1" '%s' "${output}"
}

normalize_parameters() {
  print_info "Normalizing inputs"

  normalize_variable_string "AUTO_KEYMAP"
  normalize_variable_string "AUTO_INSTALL_OS"
  normalize_variable_string "AUTO_INSTALL_EDITION"
  normalize_variable_string "AUTO_KERNEL_VERSION"
  normalize_variable_string "AUTO_HOSTNAME"
  normalize_variable_string "AUTO_DOMAIN"
  normalize_variable_string "AUTO_MAIN_DISK"
  normalize_variable_string "AUTO_SECOND_DISK"
  normalize_variable_string "AUTO_USERNAME"
  normalize_variable_string "AUTO_STAMP_FOLDER"

  normalize_variable_boolean "AUTO_SKIP_PARTITIONING"
  normalize_variable_boolean "AUTO_USE_DATA_FOLDER"
  normalize_variable_boolean "AUTO_ENCRYPT_DISKS"
  normalize_variable_boolean "AUTO_ROOT_DISABLED"
  normalize_variable_boolean "AUTO_CREATE_USER"
  normalize_variable_boolean "AUTO_CONFIRM_SETTINGS"
  normalize_variable_boolean "AUTO_REBOOT"

  if [[ "${AUTO_DISK_PWD}" == "" ]]
  then
    AUTO_DISK_PWD="file"
  fi
}

verify_install_os() {
  print_info "Verifying Install OS"
  get_exit_code contains_element "${AUTO_INSTALL_OS}" "${SUPPORTED_OSES[@]}"
  if [[ ! ${EXIT_CODE} == "0" ]]
  then
    error_msg "Invalid OS to install: '${AUTO_INSTALL_OS}'"
  fi
}

verify_kernel_version() {
  print_info "Verifying Kernel Version"
  local options
  case "${AUTO_INSTALL_OS}" in
    debian)
      options=('default' 'backport')
      get_exit_code contains_element "${AUTO_KERNEL_VERSION}" "${options[@]}"
      if [[ ! ${EXIT_CODE} == "0" ]]
      then
        error_msg "Invalid Debian kernel version to install: '${AUTO_KERNEL_VERSION}'"
      fi
      ;;

    ubuntu)
      options=('default' 'hwe' 'hwe-edge' 'hwe_edge')
      get_exit_code contains_element "${AUTO_KERNEL_VERSION}" "${options[@]}"
      if [[ ! ${EXIT_CODE} == "0" ]]
      then
        error_msg "Invalid Ubuntu kernel version to install: '${AUTO_KERNEL_VERSION}'"
      fi
      # Normalize the two edge options
      if [[ "${AUTO_KERNEL_VERSION}" == "hwe_edge" ]]
      then
        AUTO_KERNEL_VERSION="hwe-edge"
      fi
      ;;

    *)
      error_msg "ERROR! OS to install not supported: '${AUTO_INSTALL_OS}'"
      ;;
  esac
}

verify_user_configuration() {
  # If the root user is disabled, we need to force the normal user to be created
  if [[ ${AUTO_ROOT_DISABLED} == "1" ]]
  then
    AUTO_CREATE_USER=1
  fi
}

verify_mount_point() {
  print_info "Verifying mount point"
  # All we need is that /mnt is a mountpoint
  if mount | grep -q -c ' /mnt '
  then
    error_msg "Bypass of automatic partitioning has been selected but the mount point (/mnt) for the target machine is not mounted.  To skip automatic partitioning, you first must perform the partitioning manually or by script and ensure that the inteded /root and all sub-paths desired are mounted at /mnt."
  fi
}

verify_disk_input() {
  local input
  input=${!1}
  shift
  if echo "${input}" | grep -q '^/dev/'
  then
    if ! lsblk -ndpl --output NAME --include "${BLOCK_DISKS}" | grep -q "${input}"
    then
      echo "Invalid device selection option: '${input}'"
    fi
  else
    get_exit_code contains_element "${input}" "$@"
    if [[ ! ${EXIT_CODE} == "0" ]]
    then
      echo "Invalid disk selection option: '${input}'"
      exit 1
    fi
  fi
}

verify_disk_inputs() {
  print_info "Verifying disk inputs"
  if [[ ${AUTO_SKIP_PARTITIONING} == "1" ]]
  then
    verify_mount_point

    if ! echo "${AUTO_MAIN_DISK}" | grep -q '^/dev/'
    then
      error_msg "When skipping automatic partitioning, a device path (like /dev/sda) MUST be passed into AUTO_MAIN_DISK, value received: '${AUTO_MAIN_DISK}'"
    fi
  else
    verify_disk_input "AUTO_MAIN_DISK" 'smallest' 'largest'
    verify_disk_input "AUTO_SECOND_DISK" 'smallest' 'largest' 'ignore'
  fi
}

parse_main_disk() {
  print_info "Reading Main Disk Selection"

  local ventoy_disk
  ventoy_disk=$(lsblk -np -o PKNAME,LABEL | grep -i "ventoy" | cut -d' ' -f 1 || true)
  if [[ -z "${ventoy_disk}" ]]
  then
    ventoy_disk="/zzz/zzz"
  fi

  if echo "${AUTO_MAIN_DISK}" | grep -q '^/dev/'
  then
    # We have already verified the disk prior, so need need to do anything else
    MAIN_DISK_METHOD="direct"
    SELECTED_MAIN_DISK=${AUTO_MAIN_DISK}
  else
    if [[ ${AUTO_SKIP_PARTITIONING} == "1" ]]
    then
      # This should never happen, but here just in case
      error_msg "An error in configuration regarding partition has been found. Exiting."
    fi

    case "${AUTO_MAIN_DISK}" in
      smallest)
        MAIN_DISK_METHOD="smallest"
        SELECTED_MAIN_DISK=$(lsblk -ndpl --output NAME --include "${BLOCK_DISKS}" --sort SIZE | grep -v "${ventoy_disk}" | head -n 1)
        ;;

      largest)
        MAIN_DISK_METHOD="largest"
        SELECTED_MAIN_DISK=$(lsblk -ndpl --output NAME --include "${BLOCK_DISKS}" --sort SIZE | grep -v "${ventoy_disk}" | tail -n 1)
        ;;

      *)
        # Should never happen as we have already verified thie value
        error_msg "ERROR! Invalid main disk selection: '${AUTO_MAIN_DISK}'"
        ;;
    esac
  fi

  # One more validation if it is a valid disk/device locator
  if [[ ! -b "${SELECTED_MAIN_DISK}" ]]
  then
    error_msg "ERROR! Invalid main disk selected '${SELECTED_MAIN_DISK}'."
  fi

  if [[ "${SELECTED_MAIN_DISK}" == "${ventoy_disk}" ]]
  then
    error_msg "ERROR! Invalid main disk selected (ventoy) '${SELECTED_MAIN_DISK}'."
  fi

  write_log "Main disk selection method: '${MAIN_DISK_METHOD}'"
  write_log "Main disk selected: '${SELECTED_MAIN_DISK}'"
}

parse_second_disk() {
  print_info "Reading Second Disk Selection"

  print_status "    Collecting disks..."
  local devices_list
  mapfile -t devices_list < <(lsblk -ndpl --output NAME --include "${BLOCK_DISKS}" | grep -v "${SELECTED_MAIN_DISK}")

  local ventoy_disk
  ventoy_disk=$(lsblk -np -o PKNAME,LABEL | grep -i "ventoy" | cut -d' ' -f 1 || true)
  if [[ -z ${ventoy_disk} ]]
  then
    ventoy_disk="/zzz/zzz"
  fi

  write_log "checking for second disk"
  if [[ ${AUTO_SKIP_PARTITIONING} == "1" || ${#devices_list[@]} == "0" || "${SELECTED_MAIN_DISK}" == "ignore" ]]
  then
    # There is only 1 disk in the system or the user has chosen to ignore the main disk (bypassing partitioning), so regardless of what they asked for on second disk it should be ignored
    SECOND_DISK_METHOD="forced"
    SELECTED_SECOND_DISK="ignore"

    write_log "Second disk selection method: '${SECOND_DISK_METHOD}'"
    write_log "Second disk selected: ${SELECTED_SECOND_DISK}"

    return
  fi

  write_log "Checking second disk"
  write_log "AUTO_SECOND_DISK=${AUTO_SECOND_DISK}"
  case "${AUTO_SECOND_DISK}" in
    /dev/*)
      # We have already verified the disk prior, so need need to do anything else
      SECOND_DISK_METHOD="direct"
      SELECTED_SECOND_DISK=${AUTO_SECOND_DISK}
      ;;
    ignore)
      SECOND_DISK_METHOD="ignore"
      SELECTED_SECOND_DISK="ignore"
      ;;

    smallest)
      SECOND_DISK_METHOD="smallest"
      SELECTED_SECOND_DISK=$(lsblk -ndpl --output NAME --include "${BLOCK_DISKS}" --sort SIZE | grep -v "${SELECTED_MAIN_DISK}" | grep -v "${ventoy_disk}" | head -n 1)
      ;;

    largest)
      SECOND_DISK_METHOD="largest"
      SELECTED_SECOND_DISK=$(lsblk -ndpl --output NAME --include "${BLOCK_DISKS}" --sort SIZE | grep -v "${SELECTED_MAIN_DISK}" | grep -v "${ventoy_disk}" | tail -n 1)
      ;;

    *)
      # Should never happen as we have already verified thie value
      error_msg "ERROR! Invalid second disk selection: '${AUTO_SECOND_DISK}'"
      ;;
  esac

  # One more validation if it is a valid disk/device locator
  if [[ "${SELECTED_SECOND_DISK}" != "ignore" && ! -b "${SELECTED_SECOND_DISK}" ]]
  then
    error_msg "ERROR! Invalid second disk selected '${SELECTED_SECOND_DISK}'."
  fi

  # Verify it is not the same as the main disk
  if [[ "${SELECTED_SECOND_DISK}" == "${SELECTED_MAIN_DISK}" ]]
  then
    error_msg "ERROR! Main disk and second disk can not be the same disk."
  fi

  if [[ "${SELECTED_SECOND_DISK}" == "${ventoy_disk}" ]]
  then
    error_msg "ERROR! Invalid second disk selected (ventoy) '${SELECTED_MAIN_DISK}'."
  fi

  write_log "Second disk selection method: '${SECOND_DISK_METHOD}'"
  write_log "Second disk selected: '${SELECTED_SECOND_DISK}'"
}

### END: Parameter Verification  Functions

### START: Disk And Partition Functions

unmount_partitions() {
  print_info "Unmounting partitions"
  # NOTE: Cannot use umount -R here as it is a hard failure if the path requested is not mounted

  local mounted_partitions
  mapfile -t mounted_partitions < <(lsblk --output MOUNTPOINT | grep "^/mnt" | sort -r)

  swapoff -a
  for i in "${mounted_partitions[@]}"
  do
    umount "${i}"
  done
}

wipe_disks() {
  print_info "Wiping disks"

  print_info "    Wiping main disk partitions"
  wipefs --all --force "${SELECTED_MAIN_DISK}*" 2>/dev/null || true
  wipefs --all --force "${SELECTED_MAIN_DISK}" || true

  local sector_count
  sector_count=$(blockdev --getsz "${SELECTED_MAIN_DISK}")
  sector_count=$((sector_count - 100))

  dd if=/dev/zero of="${SELECTED_MAIN_DISK}" bs=512 count=100 conv=notrunc
  dd if=/dev/zero of="${SELECTED_MAIN_DISK}" bs=512 seek="${sector_count}" count=100 conv=notrunc

  partprobe "${SELECTED_MAIN_DISK}" 2>/dev/null || true

  if [[ ${SELECTED_SECOND_DISK} != "ignore" ]]
  then
    print_info "    Wiping second disk partitions"
    wipefs --all --force "${SELECTED_SECOND_DISK}*" 2>/dev/null || true
    wipefs --all --force "${SELECTED_SECOND_DISK}" || true

    local second_sector_count
    second_sector_count=$(blockdev --getsz "${SELECTED_SECOND_DISK}")
    second_sector_count=$((second_sector_count - 100))

    dd if=/dev/zero of="${SELECTED_SECOND_DISK}" bs=512 count=100 conv=notrunc
    dd if=/dev/zero of="${SELECTED_SECOND_DISK}" bs=512 seek="${second_sector_count}" count=100 conv=notrunc

    partprobe "${SELECTED_SECOND_DISK}" 2>/dev/null || true
  fi
}

create_main_partitions() {
  print_info "Creating main partitions"

  print_status "    Creating partition table"
  parted --script -a optimal "${SELECTED_MAIN_DISK}" mklabel gpt

  # Note: In this script the first two partitions are always "system" partitions while
  # the third partition (such as /dev/sda3) will ALWAYS be the main data partition.

  print_status "    Boot partitions"
  if [[ ${UEFI} == "1" ]]
  then
    # EFI partition (512mb)
    parted --script -a optimal "${SELECTED_MAIN_DISK}" mkpart "esp" fat32 0% 512MB
    parted --script -a optimal "${SELECTED_MAIN_DISK}" set 1 esp on
    # Boot partition (1gb)
    parted --script -a optimal "${SELECTED_MAIN_DISK}" mkpart "boot" ext4 512MB 1536MB

    print_status "    Main Partition"
    parted --script -a optimal "${SELECTED_MAIN_DISK}" mkpart "os" ext4 1536MB 100%
  else
    # BIOS Grub partition (1mb)
    parted --script -a optimal "${SELECTED_MAIN_DISK}" mkpart "grub" fat32 0% 1MB
    parted --script -a optimal "${SELECTED_MAIN_DISK}" set 1 bios_grub on
    # Boot partition (1gb)
    parted --script -a optimal "${SELECTED_MAIN_DISK}" mkpart "boot" ext4 1MB 1025MB
    parted --script -a optimal "${SELECTED_MAIN_DISK}" set 2 boot on

    print_status "    Main Partition"
    parted --script -a optimal "${SELECTED_MAIN_DISK}" mkpart "os" ext4 1025MB 100%
  fi

  partprobe "${SELECTED_MAIN_DISK}" 2>/dev/null || true
}

create_secondary_partitions() {
  if [[ ${SELECTED_SECOND_DISK} != "ignore" ]]
  then
    print_info "Creating secondary disk partitions"

    print_status "    Creating partition table"
    parted --script -a optimal "${SELECTED_SECOND_DISK}" mklabel gpt

    print_status "    Secondary Partition"
    parted --script -a optimal "${SELECTED_SECOND_DISK}" mkpart "data" xfs 0% 100%
    if [[ ${AUTO_ENCRYPT_DISKS} == "0" ]]
    then
      parted --script -a optimal "${SELECTED_SECOND_DISK}" set 1 lvm on
    fi

    partprobe "${SELECTED_SECOND_DISK}" 2>/dev/null || true
  fi
}

query_disk_partitions() {
  print_info "Querying partitions"

  MAIN_DISK_FIRST_PART=$(lsblk -lnp --output PATH,TYPE "${SELECTED_MAIN_DISK}" | grep "part" | sed -n '1p' | cut -d' ' -f 1)

  MAIN_DISK_SECOND_PART=$(lsblk -lnp --output PATH,TYPE "${SELECTED_MAIN_DISK}" | grep "part" | sed -n '2p' | cut -d' ' -f 1)

  MAIN_DISK_THIRD_PART=$(lsblk -lnp --output PATH,TYPE "${SELECTED_MAIN_DISK}" | grep "part" | sed -n '3p' | cut -d' ' -f 1)

  if [[ ${SELECTED_SECOND_DISK} != "ignore" ]]
  then
    SECOND_DISK_FIRST_PART=$(lsblk -lnp --output PATH,TYPE "${SELECTED_SECOND_DISK}" | grep "part" | sed -n '1p' | cut -d' ' -f 1)
  else
    SECOND_DISK_FIRST_PART="/zzz/zzz"
  fi
}

setup_encryption() {
  ENCRYPTION_FILE=""
  SECONDARY_FILE=""

  if [[ ${AUTO_ENCRYPT_DISKS} == "1" ]]
  then
    print_info "Setting up encryption"

    case "${AUTO_DISK_PWD}" in
      file)
        encrypt_main_generated_file
        ;;

      /*)
        encrypt_main_provided_file
        ;;

      *)
        encrypt_main_passphrase
        ;;
    esac
  fi

  if [[ ${SELECTED_SECOND_DISK} != "ignore" ]]
  then
    print_status "    Generating keyfile for second disk"
    SECONDARY_FILE=$(mktemp)

    openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:4096 -out "${SECONDARY_FILE}"

    print_status "    Encrypting second disk"
    cryptsetup --batch-mode -s 512 --iter-time 5000 --type luks2 luksFormat "${SECOND_DISK_FIRST_PART}" "${SECONDARY_FILE}"

    print_status "    Opening second disk"
    cryptsetup open --type luks --key-file "${SECONDARY_FILE}" "${SECOND_DISK_FIRST_PART}" cryptdata
  fi
}

encrypt_main_generated_file() {
  print_status "    Generating encryption file"

  ENCRYPTION_FILE=$(mktemp)
  write_log "ENCRYPTION_FILE=${ENCRYPTION_FILE}"

  openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:4096 -out "${ENCRYPTION_FILE}"

  print_status "    Encrypting main disk"
  cryptsetup --batch-mode -s 512 --iter-time 5000 --type luks2 luksFormat "${MAIN_DISK_THIRD_PART}" "${ENCRYPTION_FILE}"

  print_status "    Opening main disk"
  cryptsetup open --type luks --key-file "${ENCRYPTION_FILE}" "${MAIN_DISK_THIRD_PART}" cryptroot
}

encrypt_main_provided_file() {
  ENCRYPTION_FILE="${AUTO_DISK_PWD}"
  print_status "    Using encryption file"

  print_status "    Encrypting main disk"
  cryptsetup --batch-mode -s 512 --iter-time 5000 --type luks2 luksFormat "${MAIN_DISK_THIRD_PART}" "${ENCRYPTION_FILE}"

  print_status "    Opening main disk"
  cryptsetup open --type luks --key-file "${ENCRYPTION_FILE}" "${MAIN_DISK_THIRD_PART}" cryptroot
}

encrypt_main_passphrase() {
  print_status "    Using provided encryption passphrase"

  print_status "    Encrypting main disk"
  echo -n "${AUTO_DISK_PWD}" | cryptsetup --batch-mode -s 512 --iter-time 5000 --type luks2 luksFormat "${MAIN_DISK_THIRD_PART}" -

  print_status "    Opening main disk"
  echo -n "${AUTO_DISK_PWD}" | cryptsetup open --type luks "${MAIN_DISK_THIRD_PART}" cryptroot --key-file -
}

setup_lvm() {
  if [[ ${SELECTED_SECOND_DISK} != "ignore" ]]
  then
    print_info "Setting up LVM"

    local pv_volume
    if [[ ${AUTO_ENCRYPT_DISKS} == "1" ]]
    then
      pv_volume="/dev/mapper/cryptdata"
    else
      pv_volume="${SECOND_DISK_FIRST_PART}"
    fi

    pvcreate "${pv_volume}"
    vgcreate "vg_data" "${pv_volume}"

    if [[ ${AUTO_USE_DATA_FOLDER} == "1" ]]
    then
      lvcreate -l 80%VG "vg_data" -n lv_home
      lvcreate -l 10%VG "vg_data" -n lv_data
    else
      lvcreate -l 80%VG "vg_data" -n lv_home
    fi
  fi
}

format_partitions() {
  print_info "Formatting partitions"

  if [[ ${UEFI} == "1" ]]
  then
    # Format the EFI partition
    mkfs.vfat -n EFI "${MAIN_DISK_FIRST_PART}"
  fi

  # Now boot...
  mkfs.ext4 "${MAIN_DISK_SECOND_PART}"

  # Now root...
  local root_volume
  if [[ ${AUTO_ENCRYPT_DISKS} == "1" ]]
  then
    root_volume="/dev/mapper/cryptroot"
  else
    root_volume="${MAIN_DISK_THIRD_PART}"
  fi

  mkfs.ext4 "${root_volume}"

  if [[ ${SELECTED_SECOND_DISK} != "ignore" ]]
  then
    mkfs.xfs "/dev/mapper/vg_data-lv_home"
    if [[ ${AUTO_USE_DATA_FOLDER} == "1" ]]
    then
      mkfs.xfs "/dev/mapper/vg_data-lv_data"
    fi
  fi
}

mount_partitions() {
  print_info "Mounting partitions"

  # First root
  local root_volume
  if [[ ${AUTO_ENCRYPT_DISKS} == "1" ]]
  then
    root_volume="/dev/mapper/cryptroot"
  else
    root_volume="${MAIN_DISK_THIRD_PART}"
  fi
  mount -t ext4 -o errors=remount-ro "${root_volume}" /mnt

  # Now boot
  mkdir /mnt/boot
  mount -t ext4 "${MAIN_DISK_SECOND_PART}" /mnt/boot

  if [[ ${UEFI} == "1" ]]
  then
    # And EFI
    mkdir /mnt/boot/efi
    mount -t vfat "${MAIN_DISK_FIRST_PART}" /mnt/boot/efi
  fi

  if [[ ${SELECTED_SECOND_DISK} != "ignore" ]]
  then
    mkdir /mnt/home
    mount -t xfs "/dev/mapper/vg_data-lv_home" /mnt/home

    if [[ ${AUTO_USE_DATA_FOLDER} == "1" ]]
    then
      mkdir /mnt/data
      mount -t xfs "/dev/mapper/vg_data-lv_data" /mnt/data
    fi
  else
    if [[ ${AUTO_USE_DATA_FOLDER} == "1" ]]
    then
      # Just make a data directory on the root
      mkdir /mnt/data
    fi
  fi
}

### END: Disk And Partition Functions

### START: Install System

install_base_system() {
  print_info "Installing base system"

  case "${AUTO_INSTALL_OS}" in
    debian)
      install_base_system_debian
      ;;

    ubuntu)
      install_base_system_ubuntu
      ;;

    *)
      error_msg "ERROR! OS to install not supported: '${AUTO_INSTALL_OS}'"
      ;;
  esac
}

install_base_system_debian() {
  print_status "    Installing Debian"

  # Bootstrap
  debootstrap --arch "${DPKG_ARCH}" "${AUTO_INSTALL_EDITION}" /mnt "http://deb.debian.org/debian"
  chroot_install lsb-release

  # Configure apt for the rest of the installations
  configure_apt_debian
  configure_locale

  # Updates, just in case
  arch-chroot /mnt apt-get update
  arch-chroot /mnt apt-get upgrade -y --no-install-recommends

  # Standard server setup
  arch-chroot /mnt tasksel --new-install install standard

  # Can't use branches like "stable" or "oldstable" must convert to the codename like "bullseye" or "bookworm"
  local edition
  edition=$(arch-chroot /mnt lsb_release -c -s)

  # Kernel & Firmware
  local kernel_to_install="default"
  if [[ "${AUTO_KERNEL_VERSION}" == "backport" ]]
  then
    local dont_support_backports=("sid" "unstable" "rc-buggy" "experimental")
    get_exit_code contains_element "${AUTO_INSTALL_EDITION}" "${dont_support_backports[@]}"
    if [[ ! ${EXIT_CODE} == "0" ]]
    then
      # Check to see the package exists in backports, if not we'll just install the default kernel
      get_exit_code package_exists "linux-image-${DPKG_ARCH}/${edition}-backports"
      if [[ ${EXIT_CODE} == "0" ]]
      then
        kernel_to_install="backport"
      else
        write_log "Backport kernel was requested, but no backport kernel found.  Falling back to default kernel."
      fi
    else
      write_log "Backport kernel was requested, but OS edition does not support backports.  Falling back to default kernel."
    fi
  fi

  write_log "Kernel requested: '${AUTO_KERNEL_VERSION}'"
  write_log "Kernel selected: '${kernel_to_install}'"

  # Now install the kernel
  case "${kernel_to_install}" in
    default)
      chroot_install "linux-image-${DPKG_ARCH}" "linux-headers-${DPKG_ARCH}"
      ;;

    backport)
      arch-chroot /mnt apt-get -y -q --no-install-recommends install -t "${edition}-backports" "linux-image-${DPKG_ARCH}" "linux-headers-${DPKG_ARCH}"
      ;;

    *)
      error_msg "ERROR! Unable to determine kernel to install."
      ;;
  esac
}

install_base_system_ubuntu() {
  print_status "    Installing Ubuntu"

  # Bootstrap
  debootstrap --arch "${DPKG_ARCH}" "${AUTO_INSTALL_EDITION}" /mnt "http://us.archive.ubuntu.com/ubuntu"

  # Configure apt for the rest of the installations
  configure_apt_ubuntu
  configure_locale

  # Updates, just in case
  arch-chroot /mnt apt-get update
  arch-chroot /mnt apt-get upgrade -y --no-install-recommends

  chroot_install ubuntu-minimal language-pack-en lsb-release

  # The HWE kernels use the Ubuntu version # rather than the codename
  local release_ver
  release_ver=$(arch-chroot /mnt lsb_release -r -s)

  get_exit_code package_exists "linux-generic-hwe-${release_ver}-edge"
  local hwe_edge_exists=${EXIT_CODE}

  get_exit_code package_exists "linux-generic-hwe-${release_ver}"
  local hwe_exists=${EXIT_CODE}

  local kernel_to_install="default"
  if [[ "${AUTO_KERNEL_VERSION}" == "hwe-edge" ]]
  then
    if [[ ${hwe_edge_exists} == "0" ]]
    then
      kernel_to_install="hwe-edge"
    elif [[ ${hwe_exists} == "0" ]]
    then
      kernel_to_install="hwe"
      write_log "The hwe-edge kernel was requested, but the package was not found.  Found a standard hwe kernel instead and choosing that for install."
    else
      write_log "The hwe-edge kernel was requested, but no hwe packages were found.  Falling back to the default kernel."
    fi
  elif [[ "${AUTO_KERNEL_VERSION}" == "hwe" ]]
  then
    if [[ ${hwe_exists} == "0" ]]
    then
      kernel_to_install="hwe"
    else
      write_log "The hwe kernel was requested, but no hwe package was found.  Falling back to the default kernel."
    fi
  fi

  write_log "Kernel requested: '${AUTO_KERNEL_VERSION}'"
  write_log "Kernel selected: '${kernel_to_install}'"

  # Now install the kernel
  case "${kernel_to_install}" in
    default)
      chroot_install linux-generic
      ;;

    hwe)
      chroot_install "linux-generic-hwe-${release_ver}"
      ;;

    hwe-edge)
      chroot_install "linux-generic-hwe-${release_ver}-edge"
      ;;

    *)
      error_msg "ERROR! Unable to determine kernel to install."
      ;;
  esac
}

install_bootloader() {
  print_info "Installing bootloader"

  # TODO: Suport for ARM UEFI?

  if [[ ${UEFI} == "1" ]]
  then
    chroot_install os-prober efibootmgr grub-efi-amd64 grub-efi-amd64-signed shim-signed shim-helpers-amd64-signed mokutil

    arch-chroot /mnt grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=debian --recheck --no-nvram "${SELECTED_MAIN_DISK}"

    arch-chroot /mnt update-grub
  else
    print_warning "BIOS support is EXPERIMENTAL and not well tested"

    chroot_install os-prober grub-pc

    arch-chroot /mnt grub-install "${SELECTED_MAIN_DISK}"

    arch-chroot /mnt update-grub
  fi
}

### END: Install System

### START: System Configuration

configure_locale() {
  print_info "Configuring locale"

  chroot_install locales

  sed -i '/en_US.UTF-8/ c\en_US.UTF-8 UTF-8' /mnt/etc/locale.gen
  arch-chroot /mnt locale-gen

  arch-chroot /mnt update-locale --reset LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8 LANGUAGE
}

configure_apt_debian() {
  print_info "Configuring APT (Debian)"

  # Backup the one originally installed
  mv /mnt/etc/apt/sources.list /mnt/etc/apt/sources.list.bootstrapped

  # Write out sources
  {
    echo "deb http://deb.debian.org/debian ${AUTO_INSTALL_EDITION} main contrib non-free"
    echo "deb http://deb.debian.org/debian-security ${AUTO_INSTALL_EDITION}-security main contrib non-free"
    echo "deb http://deb.debian.org/debian ${AUTO_INSTALL_EDITION}-updates main contrib non-free"
  } > /mnt/etc/apt/sources.list

  # Install backports source
  local dont_support_backports=("sid" "unstable" "rc-buggy" "experimental")
  get_exit_code contains_element "${AUTO_INSTALL_EDITION}" "${dont_support_backports[@]}"
  if [[ ! ${EXIT_CODE} == "0" ]]
  then
    # Can't use branches like "stable" or "oldstable" must convert to the codename like "bullseye" or "bookworm"
    local edition
    edition=$(arch-chroot /mnt lsb_release -c -s)

    echo "deb http://deb.debian.org/debian ${edition}-backports main contrib non-free" > /mnt/etc/apt/sources.list.d/debian-backports.list
  fi

  arch-chroot /mnt apt-get update
}

configure_apt_ubuntu() {
  print_info "Configuring APT (Debian)"

  # Backup the one originally installed
  mv /mnt/etc/apt/sources.list /mnt/etc/apt/sources.list.bootstrapped

  # Write out sources
  {
    echo "deb http://us.archive.ubuntu.com/ubuntu ${AUTO_INSTALL_EDITION} main restricted universe multiverse"
    echo "deb http://us.archive.ubuntu.com/ubuntu ${AUTO_INSTALL_EDITION}-updates main restricted universe multiverse"
    echo "deb http://us.archive.ubuntu.com/ubuntu ${AUTO_INSTALL_EDITION}-backports main restricted universe multiverse"
    echo "deb http://us.archive.ubuntu.com/ubuntu ${AUTO_INSTALL_EDITION}-security main restricted universe multiverse"
  } > /mnt/etc/apt/sources.list

  arch-chroot /mnt apt-get update
}

configure_keymap() {
  print_info "Configure keymap"

  chroot_install console-setup

  echo "KEYMAP=${AUTO_KEYMAP}" > /mnt/etc/vconsole.conf
  echo "FONT=Lat15-Terminus${CONSOLE_FONT_SIZE}" >> /mnt/etc/vconsole.conf

  sed -i '/^CODESET=/ c\CODESET="Lat15"' /mnt/etc/default/console-setup
  sed -i '/^FONTFACE=/ c\FONTFACE="Terminus"' /mnt/etc/default/console-setup
  sed -i "/^FONTSIZE=/ c\FONTSIZE=\"${CONSOLE_FONT_SIZE}\"" /mnt/etc/default/console-setup

  setfont "Lat15-Terminus${CONSOLE_FONT_SIZE}"
}

configure_encryption() {
  if [[ ${AUTO_ENCRYPT_DISKS} == "1" ]]
  then
    print_info "Configuring encryption"

    mkdir -p /mnt/etc/keys

    local main_keyfile="none"
    if [[ ${ENCRYPTION_FILE} != "" ]]
    then
      main_keyfile="/mnt/boot/root.key"
      mv "${ENCRYPTION_FILE}" "${main_keyfile}"
      chmod 0400 "${main_keyfile}"
    fi

    local main_uuid
    local boot_uuid
    main_uuid=$(blkid -o value -s UUID "${MAIN_DISK_THIRD_PART}")
    boot_uuid=$(blkid -o value -s UUID "${MAIN_DISK_SECOND_PART}")
    echo "cryptroot UUID=${main_uuid} /dev/disk/by-uuid/${boot_uuid}:root.key luks,initramfs,keyscript=/lib/cryptsetup/scripts/passdev,tries=3" >> /mnt/etc/crypttab

    fix_systemd_encryption_bug

    if [[ ${SELECTED_SECOND_DISK} != "ignore" && ${SECONDARY_FILE} != "" ]]
    then
      local second_key="/etc/keys/secondary.key"
      mv "${SECONDARY_FILE}" "/mnt${second_key}"
      chmod 0400 "/mnt${second_key}"

      local second_uuid
      second_uuid=$(blkid -o value -s UUID "${SECOND_DISK_FIRST_PART}")

      echo "cryptdata UUID=${second_uuid} ${second_key} luks,tries=3" >> /mnt/etc/crypttab
    fi
  fi
}

fix_systemd_encryption_bug() {
  # BAF - There is a major bug in Systemd where it doesn't handle the passdev syntax for the key.  It expects the OPPOSITE where the first part is the file path, then a colon, then a disk identifier like UUID=xxx or LABEL=xxx.  Passdev uses a format of a disk identifier (usually a persistent devices /dev/disk/xxx, then a colon, then the path to the file.
  #
  # Systemd calls systemd-cryptsetup-generator on boot and generates some files.  We can manually call that, edit one of the files and copy it to /etc/systemd/system to override what the generator creates.
  #
  # Lastly, the chroot environment isn't running systemd so we can't do it in there.  Instead, we have to set up a script to run on boot which takes care of everything.

  write_log "Applying systemd fix for encryption"

  cat <<- 'EOF' > /mnt/etc/systemd/system/cryptsetup-first-boot.service
[Unit]
Description=First boot script to fix systemd encryption issue

[Service]
Type=oneshot
ExecStart=/srv/fix-systemd-encryption-issue.sh

[Install]
WantedBy=default.target
EOF

  arch-chroot /mnt systemctl enable cryptsetup-first-boot.service

  cat <<- 'EOF' > /mnt/srv/fix-systemd-encryption-issue.sh
#!/usr/bin/env sh

# Run the generator
/lib/systemd/system-generators/systemd-cryptsetup-generator
if [[ ! -f "/tmp/systemd-cryptsetup@cryptroot.service" ]]
then
  exit 1
fi

dest_file="/etc/systemd/system/systemd-cryptsetup@cryptroot.service"

cp "/tmp/systemd-cryptsetup@cryptroot.service" "${dest_file}"

# Now edit the file to remove the offending lines
sed -i '/^After=dev-disk-by.*root\.key\.device$/d' "${dest_file}"
sed -i '/^Requires=dev-disk-by.*root\.key\.device$/d' "${dest_file}"

# Clean up the systemctl service
systemctl disable cryptsetup-first-boot.service
rm /etc/systemd/system/cryptsetup-first-boot.service

# Clean up by deleting this script
rm $0
EOF

  chmod 0754 /mnt/srv/fix-systemd-encryption-issue.sh
}

configure_fstab() {
  print_info "Configuring fstab"

  genfstab -t UUID -p /mnt > /mnt/etc/fstab
}

configure_hostname() {
  print_info "Configuring hostname"

  local hostname
  hostname=${AUTO_HOSTNAME}
  if [[ ${hostname} == "" ]]
  then
    hostname="${AUTO_INSTALL_OS}-$((1 + RANDOM % 10000))"
  fi

  echo "${hostname}" > /mnt/etc/hostname

  local the_line
  if [[ ${AUTO_DOMAIN} == "" ]]
  then
    the_line="127.0.1.1 ${hostname}"
  else
    the_line="127.0.1.1 ${hostname}.${AUTO_DOMAIN} ${hostname}"
  fi

  if grep -q '^127.0.1.1[[:blank:]]' /mnt/etc/hosts
  then
    # Update the line
    sed -i "/^127.0.1.1[[:blank:]]/ c\\${the_line}" /mnt/etc/hosts
  else
    # Add the line
    echo -E "${the_line}" >> /mnt/etc/hosts
  fi
}

configure_timezone() {
  print_info "Configuring timezone"

  # First, the hardware clock
  arch-chroot /mnt hwclock --systohc --utc --update-drift

  # Configure the timezone
  arch-chroot /mnt timedatectl set-local-rtc 0
  arch-chroot /mnt timedatectl set-timezone "${AUTO_TIMEZONE}"
}

configure_initramfs() {
  print_info "Configuring initramfs"

  # Make sure lz4 is installed
  chroot_install lz4

  # Set that as the compression to use
  sed -i '/^COMPRESS=/ c\COMPRESS=lz4' /mnt/etc/initramfs-tools/initramfs.conf

  # Run update
  arch-chroot /mnt update-initramfs -u
}

configure_swap() {
  print_info "Configuring swap"

  # NOTE: The default calculated size is the sqrt of total ram size with a floor of 2gb.  Generally, this will NOT be enough swap space to support hibernation.  To support hibernation increasing the swapfile size after bootstrapping will be required.

  # Calculate swap file size
  local avail_ram_kib
  local avail_ram_gb
  local avail_ram_sqrt
  local size

  # Grab the amount of physical ram (in kib)
  avail_ram_kib=$(grep -i '^MemTotal' /proc/meminfo | awk '{print $2}')
  # Convert to GB
  avail_ram_gb=$(echo "scale=6; ${avail_ram_kib}/1048576*1.073741825" | bc)
  # Square root it
  avail_ram_sqrt=$(echo "scale=6; sqrt(${avail_ram_gb})" | bc)
  # Round it
  size=$(printf "%0.f\n" "${avail_ram_sqrt}")

  # Make sure the minimum is 2gb
  if [[ "${size}" -lt "1" ]]
  then
    size="2"
  fi

  # Create a swap file
  fallocate -l "${size}G" /mnt/swapfile
  chmod 600 /mnt/swapfile
  mkswap /mnt/swapfile

  # Remove any previous swap
  sed -i '/[[:blank:]]swap[[:blank:]]/ d' /mnt/etc/fstab
  # Now add the swap file
  echo "/swapfile swap swap sw 0 0" >> /mnt/etc/fstab
}

configure_networking() {
  print_info "Configuring networking"

  chroot_install network-manager netplan.io

  cat <<- 'EOF' > /mnt/etc/netplan/01-network-manage-all.yaml
# Let NetworkManager manage all devices on this system
network:
  version: 2
  renderer: NetworkManager
EOF

  arch-chroot /mnt netplan generate
}

configure_virtualization() {
  local detected_virt
  detected_virt=$(systemd-detect-virt)
  if [[ ${detected_virt} == "oracle" && "${UEFI}" = 1 && "${AUTO_INSTALL_OS}" == "debian" ]]
  then
    # On virtualbox we MUST configure this or the system won't boot correctly.  I am doing the absolute minimum I can here to get things working.  Any other virtualization configurations should be done post bootstrap.

    print_info "Setting up Virtualbox EFI"

    if [[ ! -f "/mnt/boot/efi/startup.nsh" ]]
    then
      echo "FS0:" > /mnt/boot/efi/startup.nsh
      echo "\EFI\debian\grubx64.efi" >> /mnt/boot/efi/startup.nsh
    fi

    local boot_imgs
    boot_imgs=$(arch-chroot /mnt efibootmgr)
    if ! echo "${boot_imgs}" | grep -i -q '\* debian'
    then
      efi_disk=$(lsblk -np -o PKNAME,MOUNTPOINT | grep -i "/mnt/boot/efi" | cut -d' ' -f 1)
      efi_device=$(lsblk -np -o PATH,MOUNTPOINT | grep -i "/mnt/boot/efi" | cut -d' ' -f 1)
      efi_part="$(udevadm info --query=property --name="${efi_device}" | grep -i ID_PART_ENTRY_NUM |cut -d= -f 2)"

      arch-chroot /mnt efibootmgr -c -d "${efi_disk}" -p "${efi_part}" -l '\EFI\debian\grubx64.efi' -L 'debian'
    fi
  fi
}

### END: System Configuration

### START: Install Applications

install_applications_common() {
  print_info "Installing common applications"

  # Required in all environments, many to true up standard server installation
  chroot_install apt-transport-https ca-certificates curl wget gnupg lsb-release build-essential dkms sudo acl git vim-nox python3-dev python3-setuptools python3-wheel python3-keyring python3-venv python3-pip python-is-python3 software-properties-common os-prober apparmor ssh ansible locales console-setup lz4 network-manager netplan.io cryptsetup cryptsetup-initramfs xfsprogs lvm2 dictionaries-common iamerican ibritish discover discover-data laptop-detect installation-report usbutils eject util-linux-locales
}

install_applications_debian() {
  if [[ ${AUTO_INSTALL_OS} == "debian" ]]
  then
    print_info "Installing Debian specific applications"

    chroot_install firmware-linux
  fi
}

install_applications_ubuntu() {
  if [[ ${AUTO_INSTALL_OS} == "ubuntu" ]]
  then
    print_info "Installing Ubuntu specific applications"

    chroot_install linux-firmware
  fi
}

### END: Install Applications

### START: User Configuration

setup_root() {
  if [[ ${AUTO_ROOT_DISABLED} == "0" ]]
  then
    print_info "Setting up root"

    # Unlock the root account
    arch-chroot /mnt passwd -u root

    local root_pwd
    root_pwd=${AUTO_ROOT_PWD}
    # If they did not pass a password, default it to the install os
    if [[ "${root_pwd}" == "" ]]
    then
      if [[ ${AUTO_CREATE_USER} == "1" && ${AUTO_USER_PWD} != "" ]]
      then
        root_pwd=${AUTO_USER_PWD}
      else
        root_pwd=${AUTO_INSTALL_OS}
      fi
    fi

    # Check if the password is encrypted
    if echo "${root_pwd}" | grep -q '^\$[[:digit:]]\$.*$'
    then
      # Password is encrypted
      arch-chroot /mnt usermod --password "${root_pwd}" root
    else
      # Password is plaintext
      local encrypted
      encrypted=$(echo "${root_pwd}" | openssl passwd -6 -stdin)
      arch-chroot /mnt usermod --password "${encrypted}" root
    fi

    # If root is the only user, allow login with root through SSH.  Users can of course (and should) change this after initial boot, this just allows a remote connection to start things off.
    if [[ ${AUTO_CREATE_USER} == "0" ]]
    then
      sed -i '/PermitRootLogin[[:blank:]]/ c\PermitRootLogin yes' /mnt/etc/ssh/sshd_config
    fi
  fi
}

setup_user() {
  if [[ ${AUTO_USE_DATA_FOLDER} == "1" ]]
  then
    arch-chroot /mnt groupadd --system data-user
    arch-chroot /mnt chown -R root:data-user /data
  fi

  if [[ ${AUTO_CREATE_USER} == "1" ]]
  then
    print_info "Setting up user"

    local user_name
    local user_pwd
    user_name=${AUTO_USERNAME}
    user_pwd=${AUTO_USER_PWD}
    # If they did not pass a username, default it to the install os
    if [[ "${user_name}" == "" ]]
    then
      user_name=${AUTO_INSTALL_OS}
    fi
    # If they did not pass a password, default it to the install os
    if [[ "${user_pwd}" == "" ]]
    then
      user_pwd=${AUTO_INSTALL_OS}
    fi

    arch-chroot /mnt adduser --quiet --disabled-password --gecos "${user_name}" "${user_name}"
    # Check if the password is encrypted
    if echo "${user_pwd}" | grep -q '^\$[[:digit:]]\$.*$'
    then
      # Password is encrypted
      arch-chroot /mnt usermod --password "${user_pwd}" "${user_name}"
    else
      # Password is plaintext
      local encrypted
      encrypted=$(echo "${user_pwd}" | openssl passwd -6 -stdin)
      arch-chroot /mnt usermod --password "${encrypted}" "${user_name}"
    fi

    # NOTE: I added _ssh as a group because it seems that Debian testing is currently not creating the standard ssh group but instead naming it _ssh, need to investigate further.
    groupsToAdd=(audio video plugdev netdev sudo ssh _ssh users data-user vboxsf)
    for groupToAdd in "${groupsToAdd[@]}"
    do
      group_exists=$(arch-chroot /mnt getent group "${groupToAdd}" | wc -l || true)
      if [[ ${group_exists} == "1" ]]
      then
        arch-chroot /mnt usermod -a -G "${groupToAdd}" "${user_name}"
      fi
    done
  fi
}

### END: User Configuration

### START: Wrapping Up

clean_up() {
  print_info "Cleaning up"

  # Clean apt
  arch-chroot /mnt apt-get clean
  arch-chroot /mnt apt-get autoclean

  # Trim logs
  find /mnt/var/log -type f -cmin +10 -delete
}

stamp_build() {
  print_info "Stamping build"

  local stamp_path="${AUTO_STAMP_FOLDER}"
  if [[ ${stamp_path} == "" ]]
  then
    stamp_path="srv"

    if [[ ${AUTO_USE_DATA_FOLDER} == "1" ]]
    then
      stamp_path="data"
    fi
  fi

  # Prepend the /mnt to it and create it if it doesn't exist
  stamp_path="/mnt/${stamp_path}"
  mkdir -p "${stamp_path}"

  cp "${LOG}" "${stamp_path}/install-log.log"

  if [[ -f "${OUTPUT_LOG}" ]]
  then
    cp "${OUTPUT_LOG}" "${stamp_path}/install-output.log"
  fi
}

show_complete_screen() {
  blank_line
  print_line
  print_success "INSTALL COMPLETED"
  print_info "After reboot you can configure users, install other software, etc."
  blank_line
}

### END: Wrapping Up

### START: Script sections

welcome_screen() {
  write_log "In welcome screen."
  clear
  print_line
  print_info "# Deb-Install Automated Bootstrapper"
  print_status "    https://github.com/brennanfee/linux-bootstraps"
  print_status "    Author: Brennan Fee"
  print_status "    License: MIT License"
  print_line
  print_info "Deb-Install -> Automated script to install Debian and Ubuntu systems the 'Arch Way'."
  print_line
  print_status "Script can be cancelled at any time with CTRL+C"
  blank_line
}

system_verifications() {
  check_root
  check_linux_distro
  detect_if_eufi
  check_network_connection
}

verify_parameters() {
  print_info "Verifying input parameters..."
  normalize_parameters
  loadkeys "${AUTO_KEYMAP}" # load the keymap

  verify_install_os
  verify_kernel_version
  verify_user_configuration
  verify_disk_inputs

  parse_main_disk
  parse_second_disk

  log_values
  confirm_with_user
}

setup_disks() {
  if [[ ${AUTO_SKIP_PARTITIONING} == "1" ]]
  then
    # Just bail, nothing to do
    return
  fi

  unmount_partitions
  wipe_disks
  create_main_partitions
  create_secondary_partitions
  query_disk_partitions

  setup_encryption

  setup_lvm
  format_partitions
  mount_partitions
}

install_main_system() {
  install_base_system
  install_bootloader
}

install_applications() {
  install_applications_debian
  install_applications_ubuntu
  install_applications_common
}

setup_users() {
  setup_root
  setup_user
}

do_system_configurations() {
  configure_locale
  configure_keymap
  configure_encryption
  configure_fstab
  configure_hostname
  configure_timezone
  configure_initramfs
  configure_swap
  configure_networking
  configure_virtualization
}

wrap_up() {
  clean_up
  stamp_build
  show_complete_screen
}

### END: Script sections

### START: The Main Function

do_install() {
  export DEBIAN_FRONTEND=noninteractive
  setup_installer_environment

  # Preamble
  welcome_screen

  # Verifications
  system_verifications
  install_prereqs
  verify_parameters

  # Setup the core system
  setup_disks
  install_main_system

  # Configurations
  install_applications
  do_system_configurations
  setup_users

  # Finished
  wrap_up
}

main() {
  do_install | tee -a "${OUTPUT_LOG}"

  if [[ ${AUTO_REBOOT} == "1" ]]
  then
    umount -R /mnt
    systemctl reboot
  fi
}

### END: The Main Function

main
